import React, { useState, useEffect, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, signOut, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, collection, query, where, onSnapshot } from 'firebase/firestore';

// Ensure __app_id, __firebase_config, __initial_auth_token are defined in the environment
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? initialAuthToken : null; // Changed from '__initial_auth_token' to 'initialAuthToken'

// Initialize Firebase outside the component to avoid re-initialization
let app;
let auth;
let db;

try {
  app = initializeApp(firebaseConfig);
  auth = getAuth(app);
  db = getFirestore(app);
} catch (error) {
  console.error("Error initializing Firebase:", error);
}

const translations = {
  en: {
    appName: "Gemini AI Image Generator & Chat",
    login: "Login",
    register: "Register",
    logout: "Logout",
    name: "Name",
    password: "Password",
    loginSuccess: "Logged in successfully!",
    registerSuccess: "Registered successfully! You are now logged in.",
    loginError: "Login failed: ",
    registerError: "Registration failed: ",
    generateImage: "Generate AI Image",
    imagePromptPlaceholder: "Describe the image you want to generate...",
    generatingImage: "Generating image...",
    imageGenerationSuccess: "Image generated successfully!",
    imageGenerationError: "Image generation failed: ",
    promptHelp: "Prompt Help",
    promptSuggestions: "Need ideas? Try these:",
    chatWithAI: "Chat with AI",
    chatPlaceholder: "Type your message here...",
    sendMessage: "Send",
    aiThinking: "AI is thinking...",
    chatError: "Chat error: ",
    userId: "User ID:",
    switchLanguage: "Switch to Indonesian",
    welcome: "Welcome!",
    loginToContinue: "Please login to continue.",
    anonymousLogin: "Sign In Anonymously", // This translation is now unused in the UI
    nameRequired: "Name is required.",
    passwordRequired: "Password is required.",
    imageDescription: "Generated AI Image",
    noImageYet: "No image generated yet. Enter a prompt and click 'Generate AI Image'.",
    savePrompt: "Save Prompt",
    savedPrompts: "Saved Prompts",
    noSavedPrompts: "No saved prompts.",
    delete: "Delete",
    confirmDeletePrompt: "Are you sure you want to delete this prompt?",
    usePrompt: "Use",
    selectStyle: "Select Style:",
    styleRealistic: "Realistic",
    styleCartoon: "Cartoon",
    styleAbstract: "Abstract",
    styleCinematic: "Cinematic",
    styleWatercolor: "Watercolor",
    refiningPrompt: "Refining prompt...",
    refinedPrompt: "Refined Prompt (English):",
    toggleChat: "Toggle Chat",
    generateCaption: "Generate Caption ✨",
    generatingCaption: "Generating caption...",
    captionUnavailable: "Caption generation is only available for images generated by Gemini, due to multimodal limitations.",
    captionError: "Caption generation failed: ",
    imageCaption: "Image Caption:",
    keywordPrompt: "Enter keyword for suggestions:",
    getSuggestions: "Get Suggestions ✨",
    suggestingPrompts: "Getting prompt suggestions...",
    invalidCredentials: "Invalid name or password.",
    imageGeneratorInfo: "Image generation is currently powered by DeepAI (Free Tier)."
  },
  id: {
    appName: "Generator Gambar & Obrolan AI Gemini",
    login: "Masuk",
    register: "Daftar",
    logout: "Keluar",
    name: "Nama",
    password: "Kata Sandi",
    loginSuccess: "Berhasil masuk!",
    registerSuccess: "Berhasil mendaftar! Anda sekarang masuk.",
    loginError: "Gagal masuk: ",
    registerError: "Gagal mendaftar: ",
    generateImage: "Buat Gambar AI",
    imagePromptPlaceholder: "Jelaskan gambar yang ingin Anda buat...",
    generatingImage: "Sedang membuat gambar...",
    imageGenerationSuccess: "Gambar berhasil dibuat!",
    imageGenerationError: "Gagal membuat gambar: ",
    promptHelp: "Bantuan Prompt",
    promptSuggestions: "Butuh ide? Coba ini:",
    chatWithAI: "Mengobrol dengan AI",
    chatPlaceholder: "Ketik pesan Anda di sini...",
    sendMessage: "Kirim",
    aiThinking: "AI sedang berpikir...",
    chatError: "Kesalahan obrolan: ",
    userId: "ID Pengguna:",
    switchLanguage: "Beralih ke Bahasa Inggris",
    welcome: "Selamat datang!",
    loginToContinue: "Silakan masuk untuk melanjutkan.",
    anonymousLogin: "Masuk Anonim", // This translation is now unused in the UI
    nameRequired: "Nama diperlukan.",
    passwordRequired: "Kata sandi diperlukan.",
    imageDescription: "Gambar AI yang Dihasilkan",
    noImageYet: "Belum ada gambar yang dibuat. Masukkan prompt dan klik 'Buat Gambar AI'.",
    savePrompt: "Simpan Prompt",
    savedPrompts: "Prompt Tersimpan",
    noSavedPrompts: "Tidak ada prompt yang disimpan.",
    delete: "Hapus",
    confirmDeletePrompt: "Apakah Anda yakin ingin menghapus prompt ini?",
    usePrompt: "Gunakan",
    selectStyle: "Pilih Gaya:",
    styleRealistic: "Realistis",
    styleCartoon: "Kartun",
    styleAbstract: "Abstrak",
    styleCinematic: "Sinematik",
    styleWatercolor: "Cat Air",
    refiningPrompt: "Memperbaiki prompt...",
    refinedPrompt: "Prompt yang Diperbaiki (English):",
    toggleChat: "Alihkan Obrolan",
    generateCaption: "Buat Keterangan Gambar ✨",
    generatingCaption: "Sedang membuat keterangan gambar...",
    captionUnavailable: "Pembuatan keterangan gambar hanya tersedia untuk gambar yang dihasilkan oleh Gemini, karena keterbatasan multimodal.",
    captionError: "Gagal membuat keterangan gambar: ",
    imageCaption: "Keterangan Gambar:",
    keywordPrompt: "Masukkan kata kunci untuk saran:",
    getSuggestions: "Dapatkan Saran ✨",
    suggestingPrompts: "Sedang mendapatkan saran prompt...",
    invalidCredentials: "Nama atau kata sandi tidak valid.",
    imageGeneratorInfo: "Pembuatan gambar saat ini didukung oleh DeepAI (Paket Gratis)."
  }
};

// Main App Component
const App = () => {
  const [user, setUser] = useState(null);
  const [language, setLanguage] = useState('id'); // Default language is Indonesian
  const [loadingAuth, setLoadingAuth] = useState(true);
  const [authError, setAuthError] = useState('');
  const [view, setView] = useState('login'); // 'login', 'main'
  const [currentUserId, setCurrentUserId] = useState(null);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [promptToDelete, setPromptToDelete] = useState(null);
  const [isChatBoxOpen, setIsChatBoxOpen] = useState(false); // State for chatbox visibility

  const t = translations[language]; // Current translation object

  // Hardcoded credentials for local validation
  const ADMIN_NAME = "admin"; // Admin username
  const ADMIN_PASSWORD = "buntutgrup"; // Admin password

  useEffect(() => {
    const initializeAppAndAuth = async () => {
      try {
        if (auth && db) {
          const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
            if (currentUser) {
              if (currentUser.isAnonymous) {
                 setUser(currentUser);
                 setCurrentUserId(currentUser.uid);
                 setView('main');
              }
            } else {
              setUser(null);
              setCurrentUserId(null);
              setView('login');
            }
            setLoadingAuth(false);
          });

          // No longer attempting anonymous sign-in by default here, as per user request
          // The anonymous sign-in button is explicitly removed from AuthForm.
          // Firebase Auth will only be active if the initialAuthToken is provided by the environment,
          // or if user signs in via the anonymous button (if re-added for testing).

          // If initialAuthToken is provided, sign in with it (Canvas environment)
          if (initialAuthToken) {
            await signInWithCustomToken(auth, initialAuthToken);
          }

          return () => unsubscribe();
        } else {
          console.error("Firebase services not initialized.");
          setLoadingAuth(false);
        }
      } catch (error) {
        console.error("Error during app initialization:", error);
        setAuthError(`Error initializing: ${error.message}`);
        setLoadingAuth(false);
      }
    };

    initializeAppAndAuth();
  }, []);

  const handleLogin = async (name, password) => {
    setAuthError('');
    try {
      if (!name) throw new Error(t.nameRequired);
      if (!password) throw new Error(t.passwordRequired);

      if (name === ADMIN_NAME && password === ADMIN_PASSWORD) {
        // Ensure an anonymous Firebase user exists for Firestore operations
        const firebaseUser = auth.currentUser || await signInAnonymously(auth);
        const fixedUser = { uid: firebaseUser.uid, displayName: ADMIN_NAME, isAnonymous: false }; // Use Firebase UID for Firestore access
        setUser(fixedUser);
        setCurrentUserId(fixedUser.uid);
        setView('main');
        console.log(t.loginSuccess);
      } else {
        setAuthError(t.invalidCredentials);
      }
    } catch (error) {
      setAuthError(t.loginError + error.message);
      console.error(t.loginError, error);
    }
  };

  const handleRegister = (name, password) => {
    handleLogin(name, password);
  };

  const handleLogout = async () => {
    setAuthError('');
    try {
      setUser(null);
      setCurrentUserId(null);
      setView('login');
      if (auth.currentUser) {
        await signOut(auth);
      }
      console.log("Logged out.");
    } catch (error) {
      setAuthError(`Logout failed: ${error.message}`);
      console.error("Logout failed:", error);
    }
  };

  const toggleLanguage = () => {
    setLanguage(prevLang => prevLang === 'en' ? 'id' : 'en');
  };

  const handleDeletePrompt = (prompt) => {
    setPromptToDelete(prompt);
    setShowDeleteConfirm(true);
  };

  const confirmDeletePrompt = async () => {
    if (!promptToDelete || !user || !db) return;

    try {
      const userDocRef = doc(db, `artifacts/${appId}/public/data/userPrompts`, promptToDelete.id);
      await setDoc(userDocRef, { deleted: true }, { merge: true });
      console.log(`Prompt '${promptToDelete.prompt}' marked as deleted.`);
    } catch (error) {
      console.error("Error deleting prompt:", error);
    } finally {
      setShowDeleteConfirm(false);
      setPromptToDelete(null);
    }
  };

  const cancelDeletePrompt = () => {
    setShowDeleteConfirm(false);
    setPromptToDelete(null);
  };

  if (loadingAuth) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900">
        <div className="text-xl text-gray-800 dark:text-gray-200">{t.welcome} {t.loginToContinue}</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 flex flex-col items-center justify-center dark:bg-gray-900 font-inter text-gray-900 dark:text-gray-100 relative">
      <div className="w-full max-w-4xl p-6 bg-white rounded-xl shadow-lg dark:bg-gray-800 my-4">
        <h1 className="text-4xl font-bold text-center mb-6 text-indigo-700 dark:text-indigo-400">{t.appName}</h1>

        <div className="flex justify-end mb-4">
          <button
            onClick={toggleLanguage}
            className="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600 transition-colors duration-200"
          >
            {t.switchLanguage}
          </button>
        </div>

        {authError && <p className="text-red-500 text-center mb-4">{authError}</p>}

        {view === 'login' && (
          <AuthForm
            onLogin={handleLogin}
            onRegister={handleRegister}
            // onAnonymousLogin prop removed as button is removed
            t={t}
            showAnonymousLogin={false} // Explicitly hide anonymous login button
          />
        )}

        {view === 'main' && user && (
          <>
            <div className="flex justify-between items-center mb-6">
              <span className="text-sm text-gray-600 dark:text-gray-400">{t.userId} {currentUserId}</span>
              <button
                onClick={handleLogout}
                className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors duration-200 shadow-md"
              >
                {t.logout}
              </button>
            </div>

            <ImageGenerator user={user} db={db} t={t} appId={appId} handleDeletePrompt={handleDeletePrompt} language={language} />
          </>
        )}
      </div>

      {view === 'main' && user && (
        <>
          <button
            onClick={() => setIsChatBoxOpen(!isChatBoxOpen)}
            className="fixed bottom-4 right-4 bg-indigo-600 hover:bg-indigo-700 text-white p-3 rounded-full shadow-lg z-50 flex items-center justify-center transition-all duration-300 transform hover:scale-105"
            aria-label={t.toggleChat}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
              {isChatBoxOpen ? (
                <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
              ) : (
                <path strokeLinecap="round" strokeLinejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.11C6.236 15.112 9.42 13 13 13h.01c4.418 0 8 3.582 8 8z" />
              )}
            </svg>
          </button>
          <ChatBox user={user} t={t} isOpen={isChatBoxOpen} />
        </>
      )}


      {showDeleteConfirm && (
        <ConfirmDialog
          message={t.confirmDeletePrompt}
          onConfirm={confirmDeletePrompt}
          onCancel={cancelDeletePrompt}
        />
      )}
    </div>
  );
};

// AuthForm Component
const AuthForm = ({ onLogin, onRegister, t, showAnonymousLogin }) => { // Removed onAnonymousLogin from props
  const [name, setName] = useState('');
  const [password, setPassword] = useState('');
  const [isRegistering, setIsRegistering] = useState(false);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (isRegistering) {
      onRegister(name, password);
    } else {
      onLogin(name, password);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="p-6 bg-gray-50 rounded-xl shadow-inner dark:bg-gray-700">
      <div className="mb-4">
        <label className="block text-gray-700 text-sm font-bold mb-2 dark:text-gray-300" htmlFor="name">
          {t.name}
        </label>
        <input
          type="text"
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          className="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-600 dark:border-gray-500 dark:text-gray-100"
          placeholder={t.name}
          required
        />
      </div>
      <div className="mb-6">
        <label className="block text-gray-700 text-sm font-bold mb-2 dark:text-gray-300" htmlFor="password">
          {t.password}
        </label>
        <input
          type="password"
          id="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-600 dark:border-gray-500 dark:text-gray-100"
          placeholder={t.password}
          required
        />
      </div>
      <div className="flex items-center justify-between mb-4">
        <button
          type="submit"
          className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200 shadow-md flex-grow mr-2"
        >
          {isRegistering ? t.register : t.login}
        </button>
        <button
          type="button"
          onClick={() => setIsRegistering(!isRegistering)}
          className="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200 shadow-md flex-grow ml-2 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500"
        >
          {isRegistering ? t.login : t.register}
        </button>
      </div>
      {/* Anonymous login button removed */}
      {/* {showAnonymousLogin && (
        <div className="text-center mt-4">
          <button
            type="button"
            onClick={onAnonymousLogin}
            className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200 shadow-md w-full"
          >
            {t.anonymousLogin}
          </button>
        </div>
      )} */}
    </form>
  );
};

// ImageGenerator Component
const ImageGenerator = ({ user, db, t, appId, handleDeletePrompt, language }) => {
  const [imagePrompt, setImagePrompt] = useState('');
  const [selectedStyle, setSelectedStyle] = useState('Realistic');
  const [refinedPrompt, setRefinedPrompt] = useState('');
  const [generatedImageUrl, setGeneratedImageUrl] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [isRefining, setIsRefining] = useState(false);
  const [imageError, setImageError] = useState('');
  const [savedPrompts, setSavedPrompts] = useState([]);
  const [generatedCaption, setGeneratedCaption] = useState('');
  const [isCaptioning, setIsCaptioning] = useState(false);
  const [captionError, setCaptionError] = useState('');
  const [suggestionKeyword, setSuggestionKeyword] = useState('');
  const [isSuggestingPrompts, setIsSuggestingPrompts] = useState(false);
  const [dynamicPromptSuggestions, setDynamicPromptSuggestions] = useState([]);

  // API Key for Gemini Flash (for text-based tasks)
  const GEMINI_API_KEY = "AIzaSyCeC4RzS5_GETZO0Ql8tJehZtV-rREnrpI";

  // DeepAI API for Image Generation (Free Tier)
  const DEEPAI_API_KEY = "eb2dbb43-7358-4ca8-a045-e43d7b1011e0"; // Updated DeepAI API Key
  const DEEPAI_API_URL = "https://api.deepai.org/api/text2img";

  // Fetch saved prompts
  useEffect(() => {
    if (!user || !db) return;

    const promptsCollectionRef = collection(db, `artifacts/${appId}/public/data/userPrompts`);
    const q = query(promptsCollectionRef, where("deleted", "!=", true));

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const prompts = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setSavedPrompts(prompts);
    }, (error) => {
      console.error("Error fetching saved prompts:", error);
    });

    return () => unsubscribe();
  }, [user, db, appId]);

  // Function to refine the prompt using Gemini API (translation and enhancement)
  const refinePromptWithAI = async (promptToRefine, style) => {
    setIsRefining(true);
    try {
      const chatHistory = [{
        role: "user",
        parts: [{ text: `Translate and refine the following Indonesian prompt into a detailed English prompt for an AI image generator, ensuring it's suitable for a '${style}' style image. Focus on descriptive visual details. Only provide the refined English prompt as output, no other text or explanation:\n\n${promptToRefine}` }]
      }];
      const payload = { contents: chatHistory };
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
        const refined = result.candidates[0].content.parts[0].text;
        setIsRefining(false);
        return refined;
      } else {
        setIsRefining(false);
        throw new Error(result.error?.message || "Unexpected response structure from prompt refinement AI.");
      }
    } catch (error) {
      setIsRefining(false);
      setImageError(`Prompt refinement failed: ${error.message}`);
      console.error("Prompt refinement failed:", error);
      return promptToRefine; // Fallback to original prompt if refinement fails
    }
  };

  // Function to handle image generation using DeepAI
  const handleGenerateImage = async () => {
    setImageError('');
    setGeneratedImageUrl('');
    setGeneratedCaption('');
    setCaptionError('');
    setIsGenerating(true);
    setRefinedPrompt('');

    if (!imagePrompt.trim()) {
      setImageError("Prompt cannot be empty.");
      setIsGenerating(false);
      return;
    }

    let finalPrompt = imagePrompt;
    if (language === 'id') {
      const refined = await refinePromptWithAI(imagePrompt, selectedStyle);
      finalPrompt = refined;
      setRefinedPrompt(refined);
    } else {
      finalPrompt = `${imagePrompt}, ${selectedStyle} style`;
      setRefinedPrompt(finalPrompt);
    }

    try {
      // DeepAI API Call
      const formData = new FormData();
      formData.append('text', finalPrompt);

      const response = await fetch(DEEPAI_API_URL, {
        method: 'POST',
        headers: {
          'api-key': DEEPAI_API_KEY
        },
        body: formData
      });

      if (response.ok) {
        const result = await response.json();
        if (result.output_url) {
          setGeneratedImageUrl(result.output_url);
          console.log(t.imageGenerationSuccess);
        } else {
          setImageError(`${t.imageGenerationError} DeepAI: Unexpected response format. ${JSON.stringify(result)}`);
          console.error(t.imageGenerationError, result);
        }
      } else {
        const errorText = await response.text();
        setImageError(`${t.imageGenerationError} DeepAI: ${response.status} ${response.statusText} - ${errorText}`);
        console.error(t.imageGenerationError, response.status, response.statusText, errorText);
      }
    } catch (error) {
      setImageError(t.imageGenerationError + error.message);
      console.error(t.imageGenerationError, error);
    } finally {
      setIsGenerating(false);
    }
  };

  // Function to generate a caption for the generated image using Gemini API (multimodal)
  const handleGenerateCaption = async () => {
    setCaptionError('');
    setGeneratedCaption('');
    setIsCaptioning(true);

    if (!generatedImageUrl) {
      setCaptionError("No image to caption. Please generate an image first.");
      setIsCaptioning(false);
      return;
    }

    try {
      // Fetch the image from the URL to convert it to base64
      const imageResponse = await fetch(generatedImageUrl);
      const imageBlob = await imageResponse.blob();

      // Convert Blob to Base64
      const reader = new FileReader();
      reader.readAsDataURL(imageBlob);
      reader.onloadend = async () => {
        const base64ImageData = reader.result.split(',')[1];

        const chatHistory = [{
          role: "user",
          parts: [
            { text: "Describe this image in a concise, creative, and evocative way." },
            {
              inlineData: {
                mimeType: imageBlob.type,
                data: base64ImageData
              }
            }
          ]
        }];

        const payload = { contents: chatHistory };
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
          const caption = result.candidates[0].content.parts[0].text;
          setGeneratedCaption(caption);
        } else {
          setCaptionError(t.captionError + (result.error?.message || "Unexpected response structure from caption AI."));
          console.error(t.captionError, result);
        }
        setIsCaptioning(false);
      };
      reader.onerror = () => {
        setCaptionError("Failed to read image data for captioning.");
        setIsCaptioning(false);
      };

    } catch (error) {
      setCaptionError(t.captionError + error.message);
      console.error(t.captionError, error);
      setIsCaptioning(false);
    }
  };

  // Function to get dynamic prompt suggestions based on a keyword
  const handleGetSuggestions = async () => {
    setImageError('');
    setIsSuggestingPrompts(true);
    setDynamicPromptSuggestions([]);

    if (!suggestionKeyword.trim()) {
      setImageError("Please enter a keyword for suggestions.");
      setIsSuggestingPrompts(false);
      return;
    }

    try {
      const chatHistory = [{
        role: "user",
        parts: [{ text: `Generate 5 creative, detailed, and distinct image prompts in English related to the keyword "${suggestionKeyword}". Each prompt should be suitable for AI image generation and be concise. Provide them as a numbered list. Example: "1. A vibrant coral reef..."` }]
      }];
      const payload = { contents: chatHistory };
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
        const rawSuggestions = result.candidates[0].content.parts[0].text;
        const parsedSuggestions = rawSuggestions.split('\n').filter(line => line.match(/^\d+\.\s/)).map(line => line.replace(/^\d+\.\s/, ''));
        setDynamicPromptSuggestions(parsedSuggestions);
      } else {
        setImageError(`Failed to get suggestions: ${result.error?.message || "Unknown error"}`);
        console.error("Failed to get suggestions:", result);
      }
    } catch (error) {
      setImageError(`Failed to get suggestions: ${error.message}`);
      console.error("Failed to get suggestions:", error);
    } finally {
      setIsSuggestingPrompts(false);
    }
  };

  const handleSavePrompt = async () => {
    if (!imagePrompt.trim() || !user || !db) return;

    try {
      const userDocRef = doc(db, `artifacts/${appId}/public/data/userPrompts`, Date.now().toString());
      await setDoc(userDocRef, { prompt: imagePrompt, style: selectedStyle, timestamp: new Date(), deleted: false });
      console.log("Prompt saved successfully!");
      setImagePrompt('');
      setRefinedPrompt('');
    } catch (error) {
      console.error("Error saving prompt:", error);
    }
  };

  const handleUsePrompt = (promptData) => {
    setImagePrompt(promptData.prompt);
    setSelectedStyle(promptData.style || 'Realistic');
    setRefinedPrompt('');
    setGeneratedCaption('');
    setCaptionError('');
  };

  const staticPromptSuggestionsList = [
    "A futuristic city at sunset, with flying cars and neon lights, highly detailed, cinematic.",
    "A serene forest with a hidden waterfall, mystic atmosphere, vibrant colors, realistic.",
    "An astronaut floating in space, looking at a distant galaxy, artistic, sci-fi.",
    "A cute fluffy cat wearing a tiny hat, watercolor style, whimsical.",
    "A majestic dragon perched on a mountain peak, fantasy art, epic scale.",
    "Sebuah kota futuristik saat matahari terbenam, dengan mobil terbang dan lampu neon, sangat detail, sinematik.",
    "Hutan yang tenang dengan air terjun tersembunyi, suasana mistis, warna cerah, realistis.",
    "Seorang astronot melayang di angkasa, melihat galaksi yang jauh, artistik, fiksi ilmiah.",
    "Kucing lucu berbulu halus memakai topi kecil, gaya cat air, aneh dan menyenangkan.",
    "Naga megah bertengger di puncak gunung, seni fantasi, skala epik."
  ];

  const styles = [
    { value: 'Realistic', label: t.styleRealistic },
    { value: 'Cartoon', label: t.styleCartoon },
    { value: 'Abstract', label: t.styleAbstract },
    { value: 'Cinematic', label: t.styleCinematic },
    { value: 'Watercolor', label: t.styleWatercolor },
  ];

  return (
    <div className="mb-8 p-6 bg-white rounded-xl shadow-lg dark:bg-gray-800">
      <h2 className="text-3xl font-semibold mb-4 text-indigo-600 dark:text-indigo-300">{t.generateImage}</h2>

      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">{t.imageGeneratorInfo}</p>

      <div className="mb-4">
        <label htmlFor="style-select" className="block text-gray-700 text-sm font-bold mb-2 dark:text-gray-300">
          {t.selectStyle}
        </label>
        <select
          id="style-select"
          value={selectedStyle}
          onChange={(e) => setSelectedStyle(e.target.value)}
          className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
        >
          {styles.map(style => (
            <option key={style.value} value={style.value}>{style.label}</option>
          ))}
        </select>
      </div>
      <textarea
        className="w-full p-3 mb-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
        rows="4"
        placeholder={t.imagePromptPlaceholder}
        value={imagePrompt}
        onChange={(e) => setImagePrompt(e.target.value)}
      ></textarea>

      {isRefining && (
        <p className="text-indigo-500 text-center mb-4 flex items-center justify-center">
          <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          {t.refiningPrompt}
        </p>
      )}

      {refinedPrompt && (
        <div className="mb-4 p-3 bg-indigo-50 rounded-lg dark:bg-indigo-900 border border-indigo-200 dark:border-indigo-700">
          <p className="text-sm font-semibold text-indigo-800 dark:text-indigo-200">{t.refinedPrompt}</p>
          <p className="text-gray-700 dark:text-gray-300">{refinedPrompt}</p>
        </div>
      )}

      <div className="flex flex-col sm:flex-row gap-4 mb-4">
        <button
          onClick={handleGenerateImage}
          disabled={isGenerating || isRefining}
          className="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200 shadow-md text-lg disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
        >
          {isGenerating ? (
            <>
              <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                {t.generatingImage}
              </>
            ) : t.generateImage}
          </button>
          <button
            onClick={handleSavePrompt}
            className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200 shadow-md text-lg disabled:opacity-50 disabled:cursor-not-allowed"
            disabled={!imagePrompt.trim()}
          >
            {t.savePrompt}
          </button>
        </div>

        {imageError && <p className="text-red-500 text-center mb-4">{imageError}</p>}

        {generatedImageUrl ? (
          <div className="mt-6 text-center">
            <h3 className="text-xl font-medium mb-3 dark:text-gray-200">{t.imageDescription}</h3>
            <img src={generatedImageUrl} alt={t.imageDescription} className="max-w-full h-auto rounded-lg shadow-md mx-auto border-4 border-indigo-300 dark:border-indigo-600" />
            <button
              onClick={handleGenerateCaption}
              disabled={isCaptioning}
              className="mt-4 px-6 py-2 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-lg focus:outline-none focus:shadow-outline transition-colors duration-200 shadow-md text-base disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center mx-auto"
            >
              {isCaptioning ? (
                <>
                  <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  {t.generatingCaption}
                </>
              ) : t.generateCaption}
            </button>
            {captionError && <p className="text-red-500 mt-2">{captionError}</p>}
            {generatedCaption && (
              <div className="mt-4 p-3 bg-gray-100 rounded-lg dark:bg-gray-700 border border-gray-200 dark:border-gray-600 text-left">
                <p className="text-sm font-semibold text-gray-800 dark:text-gray-200">{t.imageCaption}</p>
                <p className="text-gray-700 dark:text-gray-300">{generatedCaption}</p>
              </div>
            )}
          </div>
        ) : (
          !isGenerating && !isRefining && (
            <div className="mt-6 text-center text-gray-500 dark:text-gray-400">
              <p>{t.noImageYet}</p>
              <img
                src="https://placehold.co/400x300/a3a3a3/ffffff?text=Image+Placeholder"
                alt="Image Placeholder"
                className="max-w-full h-auto rounded-lg shadow-md mx-auto mt-4"
              />
            </div>
          )
        )}

        <div className="mt-8 p-4 bg-gray-50 rounded-xl shadow-inner dark:bg-gray-700">
          <h3 className="text-xl font-semibold mb-3 text-indigo-600 dark:text-indigo-300">{t.promptHelp}</h3>
          <p className="mb-3 text-gray-700 dark:text-gray-300">{t.promptSuggestions}</p>
          <div className="flex mb-3">
            <input
              type="text"
              className="flex-grow p-3 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
              placeholder={t.keywordPrompt}
              value={suggestionKeyword}
              onChange={(e) => setSuggestionKeyword(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && handleGetSuggestions()}
              disabled={isSuggestingPrompts}
            />
            <button
              onClick={handleGetSuggestions}
              disabled={isSuggestingPrompts || !suggestionKeyword.trim()}
              className="bg-orange-600 hover:bg-orange-700 text-white font-bold py-3 px-6 rounded-r-lg focus:outline-none focus:shadow-outline transition-colors duration-200 shadow-md disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
            >
              {isSuggestingPrompts ? (
                <>
                  <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  {t.suggestingPrompts}
                </>
              ) : t.getSuggestions}
            </button>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {(dynamicPromptSuggestions.length > 0 ? dynamicPromptSuggestions : staticPromptSuggestionsList).map((suggestion, index) => (
              <button
                key={index}
                onClick={() => handleUsePrompt({ prompt: suggestion, style: 'Realistic' })}
                className="text-left p-3 bg-gray-200 rounded-lg hover:bg-gray-300 transition-colors duration-200 text-sm dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500 shadow-sm"
              >
                {suggestion}
              </button>
            ))}
          </div>
        </div>

        <div className="mt-8 p-4 bg-gray-50 rounded-xl shadow-inner dark:bg-gray-700">
          <h3 className="text-xl font-semibold mb-3 text-indigo-600 dark:text-indigo-300">{t.savedPrompts}</h3>
          {savedPrompts.length > 0 ? (
            <ul className="space-y-2">
              {savedPrompts.map((p) => (
                <li key={p.id} className="flex justify-between items-center p-3 bg-gray-200 rounded-lg dark:bg-gray-600">
                  <span className="text-gray-700 dark:text-gray-200 text-sm flex-1 mr-4">
                    {p.prompt} {p.style && `(${p.style})`}
                  </span>
                  <div className="flex gap-2">
                    <button
                      onClick={() => handleUsePrompt(p)}
                      className="px-3 py-1 bg-indigo-500 text-white text-sm rounded-md hover:bg-indigo-600 transition-colors duration-200 shadow-sm"
                    >
                      {t.usePrompt}
                    </button>
                    <button
                      onClick={() => handleDeletePrompt(p)}
                      className="px-3 py-1 bg-red-500 text-white text-sm rounded-md hover:bg-red-600 transition-colors duration-200 shadow-sm"
                    >
                      {t.delete}
                    </button>
                  </div>
                </li>
              ))}
            </ul>
          ) : (
            <p className="text-gray-500 dark:text-gray-400">{t.noSavedPrompts}</p>
          )}
        </div>
      </div>
    );
  };

  // ChatBox Component
  const ChatBox = ({ user, t, isOpen }) => {
    const [chatHistory, setChatHistory] = useState([]);
    const [message, setMessage] = useState('');
    const [isChatting, setIsChatting] = useState(false);
    const [chatError, setChatError] = useState('');
    const chatEndRef = useRef(null);

    // API Key for Chat (Gemini 2.0 Flash)
    const GEMINI_CHAT_API_KEY = "AIzaSyCeC4RzS5_GETZO0Ql8tJehZtV-rREnrpI";

    useEffect(() => {
      chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [chatHistory, isOpen]);

    const handleSendMessage = async () => {
      if (!message.trim() || !user) return;

      setChatError('');
      setIsChatting(true);
      const newMessage = { role: "user", parts: [{ text: message }] };
      setChatHistory((prev) => [...prev, newMessage]);
      setMessage('');

      try {
        let currentChatHistory = [...chatHistory, newMessage];

        const formattedChatHistory = currentChatHistory.map(entry => ({
          role: entry.role,
          parts: entry.parts
        }));

        const payload = { contents: formattedChatHistory };
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_CHAT_API_KEY}`;

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
          const aiResponseText = result.candidates[0].content.parts[0].text;
          setChatHistory((prev) => [...prev, { role: "model", parts: [{ text: aiResponseText }] }]);
        } else {
          setChatError(t.chatError + (result.error?.message || "Unexpected response structure."));
          console.error(t.chatError, result);
        }
      } catch (error) {
        setChatError(t.chatError + error.message);
        console.error(t.chatError, error);
      } finally {
        setIsChatting(false);
      }
    };

    return (
      <div className={`fixed bottom-4 right-4 w-full max-w-sm bg-white rounded-xl shadow-lg dark:bg-gray-800 transition-transform duration-300 ease-in-out z-40
                        ${isOpen ? 'translate-x-0 opacity-100' : 'translate-x-full opacity-0 pointer-events-none'}
                        md:w-80`}>
        <div className="p-6">
          <h2 className="text-2xl font-semibold mb-4 text-indigo-600 dark:text-indigo-300">{t.chatWithAI}</h2>
          <div className="border border-gray-300 rounded-lg p-4 h-64 overflow-y-auto mb-4 bg-gray-50 dark:bg-gray-700 dark:border-gray-600 flex flex-col justify-end">
            {chatHistory.length === 0 && (
              <p className="text-center text-gray-500 dark:text-gray-400">{t.chatPlaceholder}</p>
            )}
            {chatHistory.map((msg, index) => (
              <div key={index} className={`mb-2 ${msg.role === 'user' ? 'self-end text-right' : 'self-start text-left'}`}>
                <span className={`inline-block p-2 rounded-lg ${msg.role === 'user' ? 'bg-indigo-200 text-indigo-900 dark:bg-indigo-700 dark:text-indigo-100' : 'bg-gray-200 text-gray-800 dark:bg-gray-600 dark:text-gray-200'}`}>
                  {msg.parts[0].text}
                </span>
              </div>
            ))}
            {isChatting && (
              <div className="text-left text-gray-500 italic self-start">
                <span className="inline-block p-2 rounded-lg bg-gray-200 dark:bg-gray-600 dark:text-gray-200">
                  {t.aiThinking}
                </span>
              </div>
            )}
            <div ref={chatEndRef} />
          </div>
          {chatError && <p className="text-red-500 text-center mb-4">{chatError}</p>}
          <div className="flex">
            <input
              type="text"
              className="flex-grow p-3 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100"
              placeholder={t.chatPlaceholder}
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
              disabled={isChatting}
            />
            <button
              onClick={handleSendMessage}
              disabled={isChatting || !message.trim()}
              className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-r-lg focus:outline-none focus:shadow-outline transition-colors duration-200 shadow-md disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {t.sendMessage}
            </button>
          </div>
        </div>
      </div>
    );
  };

  // Confirm Dialog Component
  const ConfirmDialog = ({ message, onConfirm, onCancel }) => {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl text-center">
          <p className="mb-4 text-gray-800 dark:text-gray-200">{message}</p>
          <div className="flex justify-center gap-4">
            <button
              onClick={onConfirm}
              className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors duration-200 shadow-md"
            >
              Yes
            </button>
            <button
              onClick={onCancel}
              className="px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition-colors duration-200 shadow-md dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500"
            >
              No
            </button>
          </div>
        </div>
      </div>
    );
  };


export default App;
